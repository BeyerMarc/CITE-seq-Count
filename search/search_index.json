{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CITE-seq-Count's documentation IMPORTANT NEWS For users who have processed data using CITE-seq-Count version 1.3.4 please rerun any data using version 1.4.0. There was a bug and the counts are not umi counts! How to cite CITE-seq-Count If you are using CITE-seq-count for you experiments, please consider citing it. You can use the DOI provided bellow. Bugs or feature requests You are welcome to address any issues on the github page","title":"Welcome to CITE-seq-Count's documentation"},{"location":"#welcome-to-cite-seq-counts-documentation","text":"","title":"Welcome to CITE-seq-Count's documentation"},{"location":"#important-news","text":"For users who have processed data using CITE-seq-Count version 1.3.4 please rerun any data using version 1.4.0. There was a bug and the counts are not umi counts!","title":"IMPORTANT NEWS"},{"location":"#how-to-cite-cite-seq-count","text":"If you are using CITE-seq-count for you experiments, please consider citing it. You can use the DOI provided bellow.","title":"How to cite CITE-seq-Count"},{"location":"#bugs-or-feature-requests","text":"You are welcome to address any issues on the github page","title":"Bugs or feature requests"},{"location":"Installation/","text":"Installation with pip CITE-seq-Count is stored on pypi. You can install it using the following command: pip install CITE-seq-Count==1.4.2 Updating pip install CITE-seq-Count --upgrade","title":"Installation"},{"location":"Installation/#installation-with-pip","text":"CITE-seq-Count is stored on pypi. You can install it using the following command: pip install CITE-seq-Count==1.4.2","title":"Installation with pip"},{"location":"Installation/#updating","text":"pip install CITE-seq-Count --upgrade","title":"Updating"},{"location":"Reading-the-output/","text":"Mtx format The mtx, matrix market , format is a sparse format for matrices. It only stores non zero values and is becoming popular in single-cell softwares. The main advantage is that it requires less space than a dense matrix and that you can easily add different feature names withint the same object. For CITE-seq-Count, the output looks like this: OUTFOLDER/ -- umi_count/ -- -- matrix.mtx.gz -- -- features.gz -- -- barcodes.mtx.gz -- read_count/ -- -- matrix.mtx.gz -- -- features.gz -- -- barcodes.mtx.gz -- unmapped.csv -- run_report.yaml File descriptions features.mtx.gz contains the feature names, in this context our tags. matrix.mtx.gz contains the cell barcodes. matrix.mtx.gz contains the actual values. read_count and umi_count contain respectively the read counts and the collapsed umi counts. For analysis you should use the umi data. The read_count can be used to check if you have an overamplification or oversequencing issue with your protocol. unmapped.csv contains the top N tags that haven't been mapped. run_report.yaml contains the parameters used for the run as well as some statistics. her is an example: Date: 2019-01-01 Running time: 50 minutes, 30 seconds CITE-seq-Count Version: 1.4.0 Reads processed: 50000000 Percentage mapped: 95 Percentage unmapped: 5 Uncorrected cells: 33 Correction: Cell barcodes collapsing threshold: 1 Cell barcodes corrected: 20000 UMI collapsing threshold: 2 UMIs corrected: 30000 Run Parameters: Read1_filename: read1.fastq.gz Read2_filename: read1.fastq.gz Cell barcode: First position: 1 Last position: 16 UMI barcode: First position: 17 Last position: 26 Tags max errors: 3 Expected cells: 150000 Start trim: 0 Packages to read MTX R I recommend using Seurat and their Read10x function to read the results. With Seurat V3: Read10x('OUTFOLDER/umi_count/', gene.column=1) With Matrix: library(Matrix) matrix_dir = \"/path_to_your_directory/out_cite_seq_count/umi_count/\" barcode.path <- paste0(matrix_dir, \"barcodes.tsv.gz\") features.path <- paste0(matrix_dir, \"features.tsv.gz\") matrix.path <- paste0(matrix_dir, \"matrix.mtx.gz\") mat <- readMM(file = matrix.path) feature.names = read.delim(features.path, header = FALSE, stringsAsFactors = FALSE) barcode.names = read.delim(barcode.path, header = FALSE, stringsAsFactors = FALSE) colnames(mat) = barcode.names$V1 rownames(mat) = feature.names$V1 Python I recommend using scanpy and their read_mtx function to read the results. Example: import scanpy import pandas as pd import os path = 'umi_cell_corrected' data = scanpy.read_mtx(os.path.join(path,'umi_count/matrix.mtx.gz')) data = data.T features = pd.read_csv(os.path.join(path, 'umi_count/features.tsv.gz'), header=None) barcodes = pd.read_csv(os.path.join(path, 'umi_count/barcodes.tsv.gz'), header=None) data.var_names = features[0] data.obs_names = barcodes[0]","title":"Reading the output"},{"location":"Reading-the-output/#mtx-format","text":"The mtx, matrix market , format is a sparse format for matrices. It only stores non zero values and is becoming popular in single-cell softwares. The main advantage is that it requires less space than a dense matrix and that you can easily add different feature names withint the same object. For CITE-seq-Count, the output looks like this: OUTFOLDER/ -- umi_count/ -- -- matrix.mtx.gz -- -- features.gz -- -- barcodes.mtx.gz -- read_count/ -- -- matrix.mtx.gz -- -- features.gz -- -- barcodes.mtx.gz -- unmapped.csv -- run_report.yaml","title":"Mtx format"},{"location":"Reading-the-output/#file-descriptions","text":"features.mtx.gz contains the feature names, in this context our tags. matrix.mtx.gz contains the cell barcodes. matrix.mtx.gz contains the actual values. read_count and umi_count contain respectively the read counts and the collapsed umi counts. For analysis you should use the umi data. The read_count can be used to check if you have an overamplification or oversequencing issue with your protocol. unmapped.csv contains the top N tags that haven't been mapped. run_report.yaml contains the parameters used for the run as well as some statistics. her is an example: Date: 2019-01-01 Running time: 50 minutes, 30 seconds CITE-seq-Count Version: 1.4.0 Reads processed: 50000000 Percentage mapped: 95 Percentage unmapped: 5 Uncorrected cells: 33 Correction: Cell barcodes collapsing threshold: 1 Cell barcodes corrected: 20000 UMI collapsing threshold: 2 UMIs corrected: 30000 Run Parameters: Read1_filename: read1.fastq.gz Read2_filename: read1.fastq.gz Cell barcode: First position: 1 Last position: 16 UMI barcode: First position: 17 Last position: 26 Tags max errors: 3 Expected cells: 150000 Start trim: 0","title":"File descriptions"},{"location":"Reading-the-output/#packages-to-read-mtx","text":"R I recommend using Seurat and their Read10x function to read the results. With Seurat V3: Read10x('OUTFOLDER/umi_count/', gene.column=1) With Matrix: library(Matrix) matrix_dir = \"/path_to_your_directory/out_cite_seq_count/umi_count/\" barcode.path <- paste0(matrix_dir, \"barcodes.tsv.gz\") features.path <- paste0(matrix_dir, \"features.tsv.gz\") matrix.path <- paste0(matrix_dir, \"matrix.mtx.gz\") mat <- readMM(file = matrix.path) feature.names = read.delim(features.path, header = FALSE, stringsAsFactors = FALSE) barcode.names = read.delim(barcode.path, header = FALSE, stringsAsFactors = FALSE) colnames(mat) = barcode.names$V1 rownames(mat) = feature.names$V1 Python I recommend using scanpy and their read_mtx function to read the results. Example: import scanpy import pandas as pd import os path = 'umi_cell_corrected' data = scanpy.read_mtx(os.path.join(path,'umi_count/matrix.mtx.gz')) data = data.T features = pd.read_csv(os.path.join(path, 'umi_count/features.tsv.gz'), header=None) barcodes = pd.read_csv(os.path.join(path, 'umi_count/barcodes.tsv.gz'), header=None) data.var_names = features[0] data.obs_names = barcodes[0]","title":"Packages to read MTX"},{"location":"Running-the-script/","text":"Introduction CITE-seq-Count is a program that outputs umi and read counts from raq fastq CITE-seq or hashing data. How to use it TLDR: CITE-seq-count -R1 TAGS_R1.fastq.gz -R2 TAGS_R2.fastq.gz -t TAG_LIST.csv -cbf X1 -cbl X2 -umif Y1 -umil Y2 -cells EXPECTED_CELLS -o OUTFOLDER The script is going to count the number of UMIs and reads mapping to an antiobdy from your CITE-Seq experiment. Here is an image explaining the expected structure of read1 and read2 from the sequencer. Options You can find a description of each option bellow. INPUT [Required] Read1 fastq file location in fastq.gz format. Read 1 typically contains Cell barcode and UMI. -R1 READ1_PATH.fastq.gz, --read1 READ1_PATH.fastq.gz [Required] Read2 fastq file location in fastq.gz. Read 2 typically contains the Antibody barcode. -R2 READ2_PATH.fastq.gz, --read2 READ2_PATH.fastq.gz [Required] The path to the csv file containing the antibody barcodes as well as their respective names. You can run tags of different length together. -t tags.csv, --tags tags.csv Antibody barcodes structure: ATGCGA,First_tag_name GTCATG,Second_tag_name GCTAGTCGTACGA,Third_tag_name GCTAGGTGTCGTA,Forth_tag_name IMPORTANT : You need to provide only the variable region of the TAG in the tags.csv. Please refer to the following examples. CASE1: Legacy barcodes. If you are using barcoes that have a T, C or G plus a polyA tail at the end, the tags.csv file should not contain those additions. Expected barcode: GCTAGTCGTACGA T AAAAAAAAAA GCTAGTCGTACGA C AAAAAAAAAA GCTAGTCGTACGA G AAAAAAAAAA GCTGTCAGCATAC T AAAAAAAAAA GCTGTCAGCATAC C AAAAAAAAAA GCTGTCAGCATAC G AAAAAAAAAA The tags.csv should only contain the part before the T GCTAGTCGTACGA,tag1 GCTGTCAGCATAC,tag2 CASE2: Constant sequences. If you are using barcoes that have a constant sequence at the end or at the start, the tags.csv file should only contain the variable part. You should also use the -trim --start-trim option to tell CITE-seq-Count where the variable part of the barcode starts Expected barcode: CGTAGTCGTAGCTA GCTAGTCGTACGA GCTAGCTGACT CGTAGTCGTAGCTA AACGTAGCTATGT GCTAGCTGACT CGTAGTCGTAGCTA GCTAGCATATCAG GCTAGCTGACT The tags.csv should only contain the variable parts and use -trim 14 to trim the first 14 bases. GCTAGTCGTACGA,tag1 AACGTAGCTATGT,tag2 GCTAGCATATCAG,tag3 BARCODING Positions of the cellular and UMI barcodes. [Required] First nucleotide of cell barcode in read 1. For Drop-seq and 10x Genomics this is typically 1. -cbf CB_FIRST, --cell_barcode_first_base CB_FIRST [Required] Last nucleotide of the cell barcode in read 1. For 10x Genomics this is typically 16. For Drop-seq this depends on the bead configuration, typically 12. -cbl CB_LAST, --cell_barcode_last_base CB_LAST [Required] First nucleotide of the UMI in read 1. For 10x Genomics this is typically 17. For Drop-seq this is typically 13. -umif UMI_FIRST, --umi_first_base UMI_FIRST [Required] Last nucleotide of the UMI in read 1. For 10x Genomics this is typically 26. For Drop-seq this is typically 20. -umil UMI_LAST, --umi_last_base UMI_LAST Example: Barcodes from 1 to 16 and UMI from 17 to 26, then this is the input you need: -cbf 1 -cbl 16 -umif 17 -umil 26 [Optional] How many errors are allowed between two cell barcodes to collapse them onto one cell. --bc_collapsing_dist N_ERRORS , default 1 [Optional] How many errors are allowed between two umi within the same cell and TAG to collapse. --umi_collapsing_dist N_ERRORS , default 2 FILTERING Filtering for structure of the antibody barcode as well as maximum errors. [OPTIONAL] Maximum Levenshtein distance allowed. This allows to catch antibody barcodes that might have --max-error errors compared to the real barcodes. (was -hd in previous versions) --max-error MAX_ERROR , default 3 Example: If we have this kind of antibody barcode: ATGCCAG The script will be looking for ATGCCAG in R2 A MAX_ERROR of 1 will allow barcodes such as ATGTCAG , having one mismatch to be counted as valid. There is a sanity check when for the MAX_ERROR value chosen to be sure you are not allowing too many mismatches and confuse your antibody barcodes. Mismatches on cell or UMI barcodes are discarded. [Optional] How many bases should we trim before starting to map. See CASE2 of special examples in the -trim N_BASES, --start-trim N_BASES , default 0 [OPTIONAL] Activate sliding window alignement. Use this when you have a protocol that has a variable sequence before the inserted TAG. --sliding-window , default False Example: The TAG: ATGCTAGCT with a variable prefix: TTCAATTTCA R2 reads: TTCA ATGCTAGCTAAAAAAAAAAAAAAAAA TTCAA ATGCTAGCTAAAAAAAAAAAAAAAA TTCAAT ATGCTAGCTAAAAAAAAAAAAAAA TTCAATT ATGCTAGCTAAAAAAAAAAAAAA TTCAATTT ATGCTAGCTAAAAAAAAAAAAA TTCAATTTC ATGCTAGCTAAAAAAAAAAAA OUTPUT You have to choose either the number of cells you expect or give it a list of cell barcodes to retrieve. [Required] Number of expected cells from your run. This will reduce the size of the output matrix. It will be used for cell barcode correction as well. -cells CELLS, --expected_cells CELLS [Optional] If you have a whitelist of barcodes produced by the cDNA data, you are using a well-plate based protocol or a platform reference, you can use this list to only extract TAGS matching those barcodes. Typically using the cell list from the mRNA data of the same experiment. This is highly recommended as knowing the true cells helps for cell barcode correction. -wl WHITELIST, --whitelist WHITELIST Example: ATGCTAGTGCTA GCTAGTCAGGAT CGACTGCTAACG [Required] Path to the result folder that will contain both read and umi mtx results as well as a run_report.yaml and potential unmapped tags. -o OUTFOLDER, --output OUTFOLDER , default Results [Optional] Will output the dense umi count matrix in a tsv format in addition to the sparse outputs. --dense OPTIONAL [Optional] Select first N reads to run on instead of all. This is usefull when trying to test out your parameters before running the whole dataset. -n FIRST_N, --first_n FIRST_N [Optional] How many threads/cores should be used by CITE-seq-Count. -T N_THREADS, --threads N_THREADS , default Number of available cores [Optional] Output file for unmapped tags. -u OUTFILE, --unmapped-tags OUTFILE , default unmapped.csv [Optional] How many unmapped tags should be written to file -ut N_UNMAPPED, --unknown-top-tags N_UNMAPPED , default 50 [Optional] Print more information about the mapping process. Only use it to find issues. Slows down the processing by a lot. --debug Version Prints out the software's currently used version","title":"Running the script"},{"location":"Running-the-script/#introduction","text":"CITE-seq-Count is a program that outputs umi and read counts from raq fastq CITE-seq or hashing data.","title":"Introduction"},{"location":"Running-the-script/#how-to-use-it","text":"TLDR: CITE-seq-count -R1 TAGS_R1.fastq.gz -R2 TAGS_R2.fastq.gz -t TAG_LIST.csv -cbf X1 -cbl X2 -umif Y1 -umil Y2 -cells EXPECTED_CELLS -o OUTFOLDER The script is going to count the number of UMIs and reads mapping to an antiobdy from your CITE-Seq experiment. Here is an image explaining the expected structure of read1 and read2 from the sequencer.","title":"How to use it"},{"location":"Running-the-script/#options","text":"You can find a description of each option bellow.","title":"Options"},{"location":"Running-the-script/#input","text":"[Required] Read1 fastq file location in fastq.gz format. Read 1 typically contains Cell barcode and UMI. -R1 READ1_PATH.fastq.gz, --read1 READ1_PATH.fastq.gz [Required] Read2 fastq file location in fastq.gz. Read 2 typically contains the Antibody barcode. -R2 READ2_PATH.fastq.gz, --read2 READ2_PATH.fastq.gz [Required] The path to the csv file containing the antibody barcodes as well as their respective names. You can run tags of different length together. -t tags.csv, --tags tags.csv","title":"INPUT"},{"location":"Running-the-script/#antibody-barcodes-structure","text":"ATGCGA,First_tag_name GTCATG,Second_tag_name GCTAGTCGTACGA,Third_tag_name GCTAGGTGTCGTA,Forth_tag_name IMPORTANT : You need to provide only the variable region of the TAG in the tags.csv. Please refer to the following examples. CASE1: Legacy barcodes. If you are using barcoes that have a T, C or G plus a polyA tail at the end, the tags.csv file should not contain those additions. Expected barcode: GCTAGTCGTACGA T AAAAAAAAAA GCTAGTCGTACGA C AAAAAAAAAA GCTAGTCGTACGA G AAAAAAAAAA GCTGTCAGCATAC T AAAAAAAAAA GCTGTCAGCATAC C AAAAAAAAAA GCTGTCAGCATAC G AAAAAAAAAA The tags.csv should only contain the part before the T GCTAGTCGTACGA,tag1 GCTGTCAGCATAC,tag2 CASE2: Constant sequences. If you are using barcoes that have a constant sequence at the end or at the start, the tags.csv file should only contain the variable part. You should also use the -trim --start-trim option to tell CITE-seq-Count where the variable part of the barcode starts Expected barcode: CGTAGTCGTAGCTA GCTAGTCGTACGA GCTAGCTGACT CGTAGTCGTAGCTA AACGTAGCTATGT GCTAGCTGACT CGTAGTCGTAGCTA GCTAGCATATCAG GCTAGCTGACT The tags.csv should only contain the variable parts and use -trim 14 to trim the first 14 bases. GCTAGTCGTACGA,tag1 AACGTAGCTATGT,tag2 GCTAGCATATCAG,tag3","title":"Antibody barcodes structure:"},{"location":"Running-the-script/#barcoding","text":"Positions of the cellular and UMI barcodes. [Required] First nucleotide of cell barcode in read 1. For Drop-seq and 10x Genomics this is typically 1. -cbf CB_FIRST, --cell_barcode_first_base CB_FIRST [Required] Last nucleotide of the cell barcode in read 1. For 10x Genomics this is typically 16. For Drop-seq this depends on the bead configuration, typically 12. -cbl CB_LAST, --cell_barcode_last_base CB_LAST [Required] First nucleotide of the UMI in read 1. For 10x Genomics this is typically 17. For Drop-seq this is typically 13. -umif UMI_FIRST, --umi_first_base UMI_FIRST [Required] Last nucleotide of the UMI in read 1. For 10x Genomics this is typically 26. For Drop-seq this is typically 20. -umil UMI_LAST, --umi_last_base UMI_LAST Example: Barcodes from 1 to 16 and UMI from 17 to 26, then this is the input you need: -cbf 1 -cbl 16 -umif 17 -umil 26 [Optional] How many errors are allowed between two cell barcodes to collapse them onto one cell. --bc_collapsing_dist N_ERRORS , default 1 [Optional] How many errors are allowed between two umi within the same cell and TAG to collapse. --umi_collapsing_dist N_ERRORS , default 2","title":"BARCODING"},{"location":"Running-the-script/#filtering","text":"Filtering for structure of the antibody barcode as well as maximum errors. [OPTIONAL] Maximum Levenshtein distance allowed. This allows to catch antibody barcodes that might have --max-error errors compared to the real barcodes. (was -hd in previous versions) --max-error MAX_ERROR , default 3 Example: If we have this kind of antibody barcode: ATGCCAG The script will be looking for ATGCCAG in R2 A MAX_ERROR of 1 will allow barcodes such as ATGTCAG , having one mismatch to be counted as valid. There is a sanity check when for the MAX_ERROR value chosen to be sure you are not allowing too many mismatches and confuse your antibody barcodes. Mismatches on cell or UMI barcodes are discarded. [Optional] How many bases should we trim before starting to map. See CASE2 of special examples in the -trim N_BASES, --start-trim N_BASES , default 0 [OPTIONAL] Activate sliding window alignement. Use this when you have a protocol that has a variable sequence before the inserted TAG. --sliding-window , default False Example: The TAG: ATGCTAGCT with a variable prefix: TTCAATTTCA R2 reads: TTCA ATGCTAGCTAAAAAAAAAAAAAAAAA TTCAA ATGCTAGCTAAAAAAAAAAAAAAAA TTCAAT ATGCTAGCTAAAAAAAAAAAAAAA TTCAATT ATGCTAGCTAAAAAAAAAAAAAA TTCAATTT ATGCTAGCTAAAAAAAAAAAAA TTCAATTTC ATGCTAGCTAAAAAAAAAAAA","title":"FILTERING"},{"location":"Running-the-script/#output","text":"You have to choose either the number of cells you expect or give it a list of cell barcodes to retrieve. [Required] Number of expected cells from your run. This will reduce the size of the output matrix. It will be used for cell barcode correction as well. -cells CELLS, --expected_cells CELLS [Optional] If you have a whitelist of barcodes produced by the cDNA data, you are using a well-plate based protocol or a platform reference, you can use this list to only extract TAGS matching those barcodes. Typically using the cell list from the mRNA data of the same experiment. This is highly recommended as knowing the true cells helps for cell barcode correction. -wl WHITELIST, --whitelist WHITELIST Example: ATGCTAGTGCTA GCTAGTCAGGAT CGACTGCTAACG [Required] Path to the result folder that will contain both read and umi mtx results as well as a run_report.yaml and potential unmapped tags. -o OUTFOLDER, --output OUTFOLDER , default Results [Optional] Will output the dense umi count matrix in a tsv format in addition to the sparse outputs. --dense","title":"OUTPUT"},{"location":"Running-the-script/#optional","text":"[Optional] Select first N reads to run on instead of all. This is usefull when trying to test out your parameters before running the whole dataset. -n FIRST_N, --first_n FIRST_N [Optional] How many threads/cores should be used by CITE-seq-Count. -T N_THREADS, --threads N_THREADS , default Number of available cores [Optional] Output file for unmapped tags. -u OUTFILE, --unmapped-tags OUTFILE , default unmapped.csv [Optional] How many unmapped tags should be written to file -ut N_UNMAPPED, --unknown-top-tags N_UNMAPPED , default 50 [Optional] Print more information about the mapping process. Only use it to find issues. Slows down the processing by a lot. --debug","title":"OPTIONAL"},{"location":"Running-the-script/#version","text":"Prints out the software's currently used version","title":"Version"}]}